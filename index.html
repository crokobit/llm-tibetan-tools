<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tibetan Reader</title>
    <script>
        // ðŸš€ IMPORTANT: Update this version number when deploying to production!
        const CSS_VERSION = '1.0.0';

        // Auto-detect development mode (localhost or 127.0.0.1)
        const isDev = window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname === '';

        if (isDev) {
            // Development mode: Disable cache and use timestamp
            document.write('<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">');
            document.write('<meta http-equiv="Pragma" content="no-cache">');
            document.write('<meta http-equiv="Expires" content="0">');
            document.write('<link rel="stylesheet" href="styles.css?t=' + Date.now() + '">');
            console.log('ðŸ”§ Development mode: CSS caching disabled');
        } else {
            // Production mode: Use version for cache busting
            document.write('<link rel="stylesheet" href="styles.css?v=' + CSS_VERSION + '">');
            console.log('ðŸš€ Production mode: CSS version ' + CSS_VERSION);
        }
    </script>

    <!-- Quill Editor CSS -->
    <link rel="stylesheet" href="https://cdn.quilljs.com/1.3.6/quill.snow.css">

    <!-- Import Map for React -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "react-quill": "https://esm.sh/react-quill@2.0.0",
            "react-quill/dist/quill.snow.css": "https://esm.sh/react-quill@2.0.0/dist/quill.snow.css"
        }
    }
    </script>

    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="module">
        import React from 'react';
        import { createRoot } from 'react-dom/client';

        // List of all files to load (relative to root, no leading ./)
        const files = [
            'utils/constants.js',
            'utils/helpers.js',
            'utils/renderHighlightedText.jsx',
            'logic/RegexGrammar.js',
            'logic/AnalysisParser.js',
            'logic/DocumentParser.js',
            'components/AnalysisLabel.jsx',
            'components/PosSelect.jsx',
            'components/EditPopover.jsx',
            'components/WordCard.jsx',
            'components/UnitRenderer.jsx',
            'components/LineRenderer.jsx',
            'components/DebugBlockEditor.jsx',
            'components/RichTextBlock.jsx',
            'components/TibetanBlock.jsx',
            'contexts/composeProviders.jsx',
            'contexts/DocumentContext.jsx',
            'contexts/EditContext.jsx',
            'contexts/SelectionContext.jsx',
            'contexts/index.jsx',
            'App.jsx'
        ];

        // Helper to resolve relative paths like '../utils/constants.js' to 'utils/constants.js'
        function resolveImportPath(baseFile, importPath) {
            if (!importPath.startsWith('.')) return importPath; // Already bare or absolute

            const stack = baseFile.split('/');
            stack.pop(); // Remove filename, keep directory

            const parts = importPath.split('/');
            for (const part of parts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (stack.length > 0) stack.pop();
                } else {
                    stack.push(part);
                }
            }
            return stack.join('/');
        }

        async function loadAndTransform() {
            try {
                const importMap = { imports: {} };
                const fileContents = {};

                // 1. Fetch all files first
                for (const file of files) {
                    const res = await fetch(`./${file}?t=${Date.now()}`);
                    if (!res.ok) throw new Error(`Failed to load ${file}`);
                    fileContents[file] = await res.text();
                }

                // 2. Transform code and rewrite imports
                for (const file of files) {
                    let code = fileContents[file];

                    // Rewrite relative imports to bare specifiers based on our file list
                    // Regex to match: import ... from '...' or import '...'
                    // We assume single quotes or double quotes
                    code = code.replace(/(import\s+(?:[\s\S]*?from\s+)?['"])([\.\/][^'"]+)(['"])/g, (match, prefix, path, suffix) => {
                        const resolved = resolveImportPath(file, path);
                        // Check if this resolved path is in our file list (ignoring extension mismatch if any, but we use full names)
                        // We just use the resolved path as the new specifier
                        return `${prefix}${resolved}${suffix}`;
                    });

                    // Transform JSX/ES6
                    const transformed = Babel.transform(code, {
                        presets: ['react'],
                        filename: file,
                        sourceMaps: 'inline'
                    }).code;

                    // Create Blob URL
                    const blob = new Blob([transformed], { type: 'text/javascript' });
                    const url = URL.createObjectURL(blob);

                    // Map the "bare specifier" (the file path) to the Blob URL
                    importMap.imports[file] = url;
                }

                // 3. Inject the dynamic import map
                const mapScript = document.createElement('script');
                mapScript.type = 'importmap';
                // Merge with existing map (React)
                const existingMap = JSON.parse(document.querySelector('script[type="importmap"]').textContent);
                const finalMap = {
                    imports: {
                        ...existingMap.imports,
                        ...importMap.imports
                    }
                };
                mapScript.textContent = JSON.stringify(finalMap);
                document.head.appendChild(mapScript);

                // 4. Import the main App
                // The App.jsx is mapped to 'App.jsx' in our map
                const module = await import(importMap.imports['App.jsx']);
                const TibetanReader = module.default;

                const root = createRoot(document.getElementById('root'));
                root.render(React.createElement(TibetanReader));

            } catch (err) {
                console.error("Error loading app:", err);
                document.getElementById('root').innerHTML = `<div class="error-message">Error: ${err.message}</div>`;
            }
        }

        loadAndTransform();
    </script>
</body>

</html>